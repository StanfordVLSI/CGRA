//; my $num_res    = parameter(Name=>'num_res', val=> 1, Min=>1, doc=>'Number of result inputs');
//; my $mux_recipe = parameter(Name=>'mux_recipe', val=> ('$i+1; $i; $N-$i'), doc=>'MUX parrten');
//; my $mask       = parameter(Name=>'mask', val=> "1001", doc=>'Mask for istantiating output MUXes');
//;
//;
//;#TODO: add support for Fs>3 by splitting each mux_recipe_arr[] on ',' boundary
//;my @mux_recipe_arr = split(';',$mux_recipe);
//;
//;sub GetMod{
//;  my $i;
//;  my $N;
//;
//;  ($i, $N) = @_;
//;
//;  if ($i < 0) {
//;    return GetMod($i+$N,$N);
//;  }
//;  elsif($i >= $N) {
//;    return GetMod($i-$N,$N);
//;  }
//;  else{
//;    return $i;
//;  }
//;}
//;
//;
//;my $N = length($mask);
//;my $O = () = $mask =~ /1/gi;
//;
//;
/*

Pattern length  : N = `$N`
Number of MUXes : O = `$O` (same as the number ones in the pattern)

*/
module `mname`  #(
  parameter Width   = 16
) (
  input                            clk,
  input                            rst_n,

  input        [`$N-1`:0][2:0]         cfg,

  input        [`$N-1`:0][Width - 1:0] in0,
  input        [`$N-1`:0][Width - 1:0] in1,
  input        [`$N-1`:0][Width - 1:0] in2,
  input        [ `$num_res-1`:0][Width - 1:0] res,

  output logic [`$N-1`:0][Width - 1:0] out
);
//;
//; my $mux = generate_base('test_mux_var', 'test_mux', "use_ff"=>1, "num_inp" => $num_res+(scalar @mux_recipe_arr) );
//; my $j = 0;
//; for (my $i=0; $i < $N; $i = $i + 1){
//;   if( substr($mask, $i, 1)=="0"){
assign out[`$i`] = in1[`$i`];
//;     next;
//;   }
//;
//;   my $i_mux = $mux;
//;   if($i>0){
//;    $i_mux = clone($mux, "test_mux_$i");
//;   }


`$i_mux->mname()` #(.DataWidth(Width)) `$i_mux->iname()`
(
  .clk            (clk),
  .rst_n          (rst_n),

  .data_in_0      (in0[`GetMod(eval($mux_recipe_arr[0]), ($mux_recipe_arr[0]=~/^\$[iN]/) ? $O : $N)`]),
  .data_in_1      (in1[`GetMod(eval($mux_recipe_arr[1]), ($mux_recipe_arr[0]=~/^\$[iN]/) ? $O : $N)`]),
  .data_in_2      (in2[`GetMod(eval($mux_recipe_arr[2]), ($mux_recipe_arr[0]=~/^\$[iN]/) ? $O : $N)`]),
  .data_in_3      (res),
  .sel            (cfg[`$i`][1:0]),
  .reg_en         (cfg[`$i`][2]),
  .res            (out[`$i`])
);

//;   $j = $j + 1;
//;}

endmodule

/*
//module sb_dir  #(
module `mname`  #(
  parameter NumTrck = 6,
  parameter Width   = 16
) (
  input                clk,
  input                rst_n,

  input        [NumTrck-1:0][3:0] cfg,

  input        [NumTrck-1:0][Width - 1:0] in0,
  input        [NumTrck-1:0][Width - 1:0] in1,
  input        [NumTrck-1:0][Width - 1:0] in2,
  input                     [Width - 1:0] res,
//  input                     [Width - 1:0] res1,

  output logic [NumTrck-1:0][Width - 1:0] out
);

genvar ggg;

generate
  for (ggg = 0; ggg < NumTrck; ggg = ggg +1) begin : GEN_SB

    logic [Width - 1:0] out_w;
    logic [Width - 1:0] out_reg;

    always_comb begin
        case (cfg[ggg][2:0])
          3'h0: out_w = in0[ggg];
          3'h1: out_w = in1[ggg];
          3'h2: out_w = in2[ggg];
          3'h3: out_w = res;
//          3'h4: out_w = res1;

          default: out_w = res;
        endcase
    end


    always_ff @(posedge clk or negedge rst_n) begin
      if(~rst_n) begin
        out_reg <= 16'h0;
      end else begin
        out_reg <= out_w;
      end
    end

    assign out[ggg] = cfg[ggg][3] ? out_reg : out_w;
    //assign out[ggg] = out_w;
  end
endgenerate
endmodule
*/



